---
title: "R Notebook"
output: html_notebook
---

# Function
```{r}

pw.aln <- function(t, thresholds, file.log = NULL, gap.open = 20, maxval = 10^10) {
  
  if(!is.null(file.log)) {
    write('', file=file.log, append=F)
  }
  for(threshold in thresholds) {
  
    irow = 1
    while(irow < nrow(t)) {
      # print(threshold)
      # print(irow)
      
      # if a base fragment of irow is already within some base fragment
      idx = (t[,'V4'] <= t[irow,'V4']) & (t[,'V5'] >= t[irow,'V5'])
      idx[irow] = F
      if(sum(idx) > 0){
        irow <- irow + 1
        next
      }
      
      # if a query fragment of irow is already within some query fragment
      idx = (t[,'V2'] <= t[irow,'V2']) & (t[,'V3'] >= t[irow,'V3'])
      idx[irow] = F
      if(sum(idx) > 0){
        irow <- irow + 1
        next
      }
      
      
      idx = abs(t[,'V2'] - (t[irow,'V3']))
      # idx = apply(cbind(abs(t[,'V2'] - (t[irow,'V3'])), abs(t[,'V4'] - (t[irow,'V5']))), 1, min)
      idx[irow] = maxval
      idx[t[,'V2'] <= t[irow,'V2']] = maxval
      idx[t[,'V4'] <= t[irow,'V4']] = maxval
      
      # If new fragment is in irow fragment by query
      idx.inside = (t[,'V2'] >= t[irow,'V2']) & (t[,'V3'] <= t[irow,'V3'])
      idx[idx.inside] = maxval
      
      # If new fragment is in irow fragment by base
      idx.inside = (t[,'V4'] >= t[irow,'V4']) & (t[,'V5'] <= t[irow,'V5'])
      idx[idx.inside] = maxval
      
      idx[t$dir != t$dir[irow]] = maxval
      
      idx[abs(t[, 'V2'] - t[irow, 'V3']) > threshold] = maxval
      idx[abs(t[, 'V4'] - t[irow, 'V5']) > threshold] = maxval
      
      if(min(idx) == maxval){
        irow <- irow + 1
        next
      }
      
      idx = which(idx == min(idx))
  
      if(length(idx) == 0) {
        irow <- irow + 1
        next
      }
      idx = idx[1]
      
      if(threshold > 10^4){
        n.char = 50
        n.char.thresh = 100  
      } else {
        n.char = 9
        n.char.thresh = 50
      }
      
      
      d.tmp = 0
      while (d.tmp < n.char.thresh) {
        n.char = n.char + 1
        pos.query.start = max(1, t[irow, 'V3'] - n.char + sumGapLastN(t[irow, 'V8'], n.char))
        pos.query.end = t[idx, 'V2'] + n.char - sumGapFirstN(t[idx, 'V8'], n.char)
        
        
        pos.base.start = max(1, t[irow, 'V5'] - n.char + sumGapLastN(t[irow, 'V9'], n.char))
        pos.base.end = t[idx, 'V4'] + n.char - sumGapFirstN(t[idx, 'V9'], n.char)
        
        d.tmp = min(pos.query.end - pos.query.start, pos.base.end - pos.base.start)
      }
      
      if(t$dir[irow] == 0){
        base.fas = base.fas.fw
      } else {
        base.fas = base.fas.bw
      }
      
      seq.query <- toupper(query.fas.chr[(pos.query.start+1):(pos.query.end-1)])
      seq.base <- toupper(base.fas[(pos.base.start+1):(pos.base.end-1)])  
      
      globalAlign<- pairwiseAlignment(paste0(seq.query, collapse=''), 
                                      paste0(seq.base, collapse=''), gapOpening = gap.open, type="global")
      globalAlign 
      
      if(!is.null(file.log)) {
        write(paste((pos.query.start+1), (pos.query.end-1), as.character(alignedPattern(globalAlign))),
              file=file.log, append=TRUE)
        write(paste((pos.base.start+1), (pos.base.end-1), as.character(alignedSubject(globalAlign))), 
              file=file.log, append=TRUE)
        write('\n', file=file.log, append=TRUE)
      }
      
      
      seq.query.new = paste(removeLastN(t[irow, 'V8'], n.char),  
                            alignedPattern(globalAlign), 
                            removeFirstN(t[idx, 'V8'], n.char), sep = '')
      
      seq.base.new = paste(removeLastN(t[irow, 'V9'], n.char),  
                           alignedSubject(globalAlign), 
                           removeFirstN(t[idx, 'V9'], n.char), sep = '')
      
      if(nchar(seq.query.new) != nchar(seq.base.new)) stop('aa')
      
      t1 <- t
      
      t[irow, 'V8'] <- seq.query.new
      t[irow, 'V9'] <- seq.base.new
      
      t[irow, 'V3'] <- t[idx, 'V3']
      t[irow, 'V5'] <- t[idx, 'V5']
      t[irow, 'V7'] <- nchar(seq.base.new)
      
      t <- t[-idx,]
      
      # s1 = seq.base.new
      # s2 = paste0(base.fas.fw[t[irow,'V4']:t[irow,'V5']], collapse = '')
      
      s.base = strsplit(seq.base.new,'')[[1]]
      idx.nogap.base = which(s.base != '-')
      if(length(idx.nogap.base) != abs(t[irow,'V5'] - t[irow,'V4']) + 1) stop('wrong in base')
      
      s.query = strsplit(seq.query.new,'')[[1]]
      idx.nogap.query = which(s.query != '-')
      if(length(idx.nogap.query) != abs(t[irow,'V3'] - t[irow,'V2']) + 1) stop('wrong in query')
      
      
      if(idx < irow) {
        irow = irow - 1
      }    
      
      rownames(t) <- NULL
    }
  }
  return(t)
}
```




# Setup
```{r, message=FALSE}
library(ggplot2)
library(Biostrings)
library('seqinr')
library('spgs')  # reverseComplement("actg")
source("/Users/anna/OneDrive/pushkin/cryptic/nanopore/scripts/synteny_infer.R")

path.base = '/Volumes/Samsung_T5/vienn/tair/'
path.query = '/Volumes/Samsung_T5/vienn/renamed/'
path.blast.res <- '/Volumes/Samsung_T5/vienn/blast_res/'


files.base = list.files(path = path.base, pattern = ".fas")
base.pref = 'TAIR10_chr'

files.query = list.files(path = path.query, pattern = ".fasta")
query.name = gsub("*.fasta","",files.query)
```



# Read data
```{r}

query.chr = 1
base.chr = 1

i.query = 1  # which accession to use

base.file = paste0(base.pref, query.chr ,'.fas', collapse = '')
query.file = files.query[i.query]
pref.blsat.res = paste0(query.name[i.query], '_', query.chr, '_', collapse = '')

base.fas.fw = read.fasta(paste(path.base, base.file, sep = ''))
query.fas = read.fasta(paste(path.query, query.file, sep = ''))

base.fas.fw = base.fas.fw[[base.chr]]
base.fas.bw = reverseComplement(base.fas.fw)
base.len = length(base.fas.fw)

query.fas.chr = query.fas[[query.chr]]

blast.res.file <- paste0(pref.blsat.res, as.character(base.chr), '.txt', collapse = '');

```



# Read blast results
```{r}


t = read.table(paste(path.blast.res, blast.res.file, sep = ''), stringsAsFactors = F, header = F)



# Remove duplicates
# t = t[!duplicated(t[,'V1']),]

# Remove short
t = t[t[,'V7'] > 500,]

# Remove low quality
quality.cutoff = 0.95
t = t[t[,'V6'] > quality.cutoff,]

# direction
t$dir = c()
for(irow in 1:nrow(t)) {
  if(t[irow,'V5'] < t[irow,'V4']) {
    
    pos1 = t[irow,'V5']
    pos2 = t[irow,'V4']
    
    t[irow,'V5'] <- length(base.fas.bw) - pos1 + 1
    t[irow,'V4'] <- length(base.fas.bw) - pos2 + 1
    t[irow, 'dir'] = 1
  } else {
    t[irow, 'dir'] = 0
  }
}

# Get right positions
start.pos = as.numeric(sapply(strsplit(t[,1], "\\|"), "[", 4)) - 1
t[,2:3] = t[,2:3] + start.pos

rownames(t) <- NULL

# check
for(irow in 1:nrow(t)) {
  if(nchar(t[irow,'V8']) != nchar(t[irow,'V9'])) stop('aaa')
}

source("/Users/anna/OneDrive/pushkin/cryptic/nanopore/scripts/synteny_infer.R")
checkCorrespToGenome(t, query.fas = query.fas.chr, 
                     base.fas.fw = base.fas.fw, 
                     base.fas.bw = base.fas.bw)
showt(t)


```





# First glue
```{r}

t = t[order(t[,'V4']),]

ipos = 1
while(ipos < nrow(t)) {
  # print(ipos)
  idx = which((t[,'V4'] == (t[ipos,'V5'] + 1)) & (t[,'V2'] == (t[ipos,'V3'] + 1)))
  if (length(idx) == 0){
    ipos = ipos+1
    next
  }
  
  # if(idx != (ipos+1)) print(idx)  # glue with not the next record
  
  t[ipos, 'V3'] <- t[idx, 'V3']
  t[ipos, 'V5'] <- t[idx, 'V5']
  t[ipos, 'V7'] <- t[ipos, 'V7'] + t[idx, 'V7']
  t[ipos, 'V8'] <- paste(t[ipos, 'V8'], t[idx, 'V8'], sep = '')
  t[ipos, 'V9'] <- paste(t[ipos, 'V9'], t[idx, 'V9'], sep = '')
  t <- t[-idx,]
}


rownames(t) <- NULL
t0 = t

```


## Distribution of gaps
```{r}

plot(t[,'V4'], t[,'V2'])


plot( (base.len + 1) * t[,'dir'] + t[,'V4'] * ((-1) ^ t[,'dir']), t[,'V2'])

hist(log(t[2:(nrow(t)),'V2'] - t[1:(nrow(t)-1),'V3'], base = 10), 100)

sum(t[2:(nrow(t)),'V2'] - t[1:(nrow(t)-1),'V3'] < 10^3)
intersect(which(t[2:(nrow(t)),'V2'] - t[1:(nrow(t)-1),'V3'] > 10^4),
          which(t[2:(nrow(t)),'V4'] - t[1:(nrow(t)-1),'V5'] > 10^4))

setdiff(which(t[2:(nrow(t)),'V2'] - t[1:(nrow(t)-1),'V3'] > 10^4),
          which(t[2:(nrow(t)),'V4'] - t[1:(nrow(t)-1),'V5'] > 10^4))

```

# pairwise alignment
```{r}

file.log <- '/Users/anna/OneDrive/vienn/pacbio/log.txt'
thresholds = c(100, 1000, 2000)
# thresholds = c(1000)

t = pw.aln(t, thresholds, file.log)
showt(t)

t1 = t


```

# Remove complete overlap from both sides (base an query)
```{r}
t.base = t

for(irow in 1:nrow(t.base)) {
  if(t.base[irow, 'dir'] == 1) {
    
    b1 <- t.base[irow,'V4']
    b2 <- t.base[irow,'V5']
    
    t.base[irow,'V4'] <- base.len - b1 + 1
    t.base[irow,'V5'] <- base.len - b2 + 1
  } 
}
t.base = t.base[order(t.base['V2']),]
showt(t.base)

# ------------------------------
# Overlap in base
irow = 1
while(irow < nrow(t.base)) {
  # index of all, that overlap with the current one (irow) in the right side
  idx = which((t.base[,'V4'] <= t.base[irow,'V4']) & 
                (t.base[,'V5'] >= t.base[irow,'V5']))
  if(length(idx) > 1) {
    t.base = t.base[-irow,] 
  } else {
    irow = irow + 1
  }
}

# Overlap in query
irow = 1
while(irow < nrow(t.base)) {
  # index of all, that overlap with the current one (irow) in the right side
  idx = which((t.base[,'V2'] <= t.base[irow,'V2']) & 
                (t.base[,'V3'] >= t.base[irow,'V3']))
  if(length(idx) > 1) {
    t.base = t.base[-irow,] 
  } else {
    irow = irow + 1
  }
}

showt(t.base)

ids.remove = which((t.base[, 'dir'] > 0) & (t.base[, 'V7'] < 5000))
if(length(ids.remove) > 0) {
  t.base = t.base[-ids.remove,]
}


idx = rep(F, base.len)
for(irow in 1:nrow(t.base)){
  idx[t.base[irow,'V4']:t.base[irow,'V5']] = T
}

coverage = sum(idx) / base.len
print(coverage)


idx = rep(F, length(query.fas.chr))
for(irow in 1:nrow(t.base)){
  idx[t.base[irow,'V2']:t.base[irow,'V3']] = T
}

coverage = sum(idx) / length(idx)
print(coverage)

# remove distant outliers


plot(t.base[,'V4'], t.base[,'V2'])

t = t[rownames(t.base),]
```


```{r}
t = pw.aln(t, c(3000, 4000))

```

# Plot syntheny blocks
```{r fig.width=3, fig.height=3}
df = c()
for(i in 1:nrow(t)) {
  if(t$dir[i] == 0){
    df = rbind(df, c(t[i, 'V2'], t[i, 'V4'], i, 0))
    df = rbind(df, c(t[i, 'V3'], t[i, 'V5'], i, 0))
  } else {
    df = rbind(df, c(t[i, 'V2'], length(base.fas.fw) - t[i, 'V4'] + 1, i, 1))
    df = rbind(df, c(t[i, 'V3'], length(base.fas.fw) - t[i, 'V5'] + 1, i, 1))
  }
    
}

df = as.data.frame(df)
df$clr <- df$V3 %% 2;
p <- ggplot(df, aes(x = V1, y=V2, color = as.factor(V4), group=as.factor(V3)  )) + 
  geom_line(show.legend = FALSE) + theme_bw()
p

```



# Get total alignment
```{r}
t.base = t
for(irow in 1:nrow(t.base)) {
  if(t.base[irow, 'dir'] == 1) {
    
    b1 <- t.base[irow,'V4']
    b2 <- t.base[irow,'V5']
    
    t.base[irow,'V4'] <- base.len - b2 + 1
    t.base[irow,'V5'] <- base.len - b1 + 1
    
    q1 <- t.base[irow,'V2']
    q2 <- t.base[irow,'V3']

    t.base[irow,'V2'] <- -q2
    t.base[irow,'V3'] <- -q1
    
    t.base[irow, 'V8'] <- reverseComplement(t.base[irow, 'V8'])
    t.base[irow, 'V9'] <- reverseComplement(t.base[irow, 'V9'])
  } 
}

aln.pos = rep(0, base.len)
aln.nt = rep('-', base.len)

for(irow in 1:nrow(t)) {
  s.q = strsplit(t[irow, 'V8'], '')[[1]]
  s.b = strsplit(t[irow, 'V9'], '')[[1]]
  
  print(sum(s.q != s.b))
  
  pos.q = rep(0, t[irow, 'V7'])
  pos.q[s.q != '-'] <- t[irow, 'V2']:t[irow, 'V3']
  pos.b = t[irow, 'V4']:t[irow, 'V5']
  
  idx.b = which(s.b == '-')
  if(length(idx.b) > 0) {
    pos.q = pos.q[-idx.b]
    s.q = s.q[-idx.b]  
  }
  
  
  # if(sum(aln.nt != '-') == 0) {
    aln.pos[pos.b] = pos.q
    aln.nt[pos.b] = s.q
  # } else {
  #   stop('ss')
  # }
}
```

# Get SNPs
```{r}
possible.snp.pos = which((aln.nt != '-') & (aln.nt != toupper(base.fas.fw)))

flanking.match = 5
idx = (snp.pos[-1] - snp.pos[-length(snp.pos)]) > 5
idx = c(idx, T) & c(T, idx)
snp.pos = possible.snp.pos[idx]



```



# Mobilome
```{r}
mobilome <- c()

for(irow in 1:nrow(t)) {
# for(irow in 1:50) {
  s.query <- strsplit(t[irow, 'V8'], '')[[1]]
  s.base <- strsplit(t[irow, 'V9'], '')[[1]]
  s <- c()
  f <- ''
  for(icol in 1:length(s.query)){
    if(s.query[icol] == '-') {
      if(f == 'query'){
        if(length(s) > 0) mobilome <- c(mobilome, paste0(s, collapse =''))
        s <- c()
      }
      f = 'base' # get sequence from base
      s <- c(s, s.base[icol])
    } else if(s.base[icol] == '-') {
      if(f == 'base'){ 
        if(length(s) > 0) mobilome <- c(mobilome, paste0(s, collapse =''))
        s <- c()
      }
      f = 'query'
      s <- c(s, s.query[icol])
    } else if (length(s) > 0) {
      mobilome <- c(mobilome, paste0(s, collapse =''))
      s <- c()
      f = ''
    }
  }
}


```





```{r}

mobilome.t <- table(mobilome)
mobilome.unique.len <- sapply(names(mobilome.t), nchar)
mobilome.t = mobilome.t[order(mobilome.unique.len)]
mobilome.unique.len <- sapply(names(mobilome.t), nchar)



plot(log(mobilome.t, base = 2))



idx <- (mobilome.t > 2^2) & (mobilome.t < 2^6) &
  (rank(mobilome.unique.len) > length(mobilome.t)/3)

mobilome.t[idx]


mobilome.t[(mobilome.unique.len>15) & (mobilome.unique.len<100)]


for(len in 15:50){
  mobilome.prev = names(mobilome.t[mobilome.unique.len == (len-1)])

  tmp = mobilome.t[mobilome.unique.len == (len-1)]
  tmp[tmp >1]

  mobilome.prev = names(tmp[tmp >1])

  scores = c()
  for(i in 1:length(mobilome.prev)) {
    for(j in i:length(mobilome.prev)) {
      if (i == j) next
        seq1 <- mobilome.prev[i]
        seq2 <- mobilome.prev[j]
        globalAlign<- pairwiseAlignment(seq1, seq2)
        scores = rbind(scores, c(i, j, globalAlign@score))
    }
  }
}

```



<!-- ```{r} -->
<!-- nts <- c('A', 'C', 'G', 'T') -->
<!-- cnt <- mobilome.t[nts] -->
<!-- freq <- cnt / sum(cnt) -->

<!-- cmb <- gtools::permutations(4, 7, repeats.allowed=TRUE) -->
<!-- nts.cmb <- sapply(1:nrow(cmb), function(i) paste0(nts[cmb[i,]], collapse = '')) -->

<!-- cnt.cmb <- mobilome.t[nts.cmb] -->

<!-- freq.cmb <- sapply(1:nrow(cmb), function(i) prod(freq[cmb[i,]])) -->

<!-- plot(freq.cmb, cnt.cmb) -->

<!-- text(freq.cmb, cnt.cmb, nts.cmb, cex=0.5, pos=3,col="red", adj = c(0,1)) -->

<!-- ``` -->


<!-- ```{r} -->
<!-- d<-head(mtcars) -->
<!-- plot(d[,'wt'], d[,'mpg'],  -->
<!--      main="Milage vs. Car Weight\n~~~~~~~~~~~~~~~~~~~", -->
<!--       xlab="Weight", ylab="Miles/(US) gallon", -->
<!--       pch=19, col="darkgreen") -->
<!-- text(d[,'wt'], d[,'mpg'],  row.names(d), -->
<!--      cex=0.65, pos=3,col="red")  -->
<!-- ``` -->


<!-- ```{r} -->
<!-- # find the largest list, which is sorted. -->

<!-- hist(abs(t[2:nrow(t),'V4'] - t[1:(nrow(t) - 1),'V4'])) -->

<!-- plot(t[,'V4'], t[,'V2']) -->

<!-- t = t[order(t[,'V4']),] -->


<!-- base.pos = list() -->
<!-- for(imatch in 1:nrow(t)) { -->

<!--   query.id <- t[imatch, 'V2']:t[imatch, 'V3'] -->
<!--   base.id <- t[imatch, 'V4']:t[imatch, 'V5'] -->

<!--   t[imatch, 'V8'] = toupper(t[imatch, 'V8']) -->
<!--   t[imatch, 'V9'] = toupper(t[imatch, 'V9']) -->

<!--   query.seq = strsplit(t[imatch, 'V8'], "")[[1]] -->
<!--   base.seq = strsplit(t[imatch, 'V9'], "")[[1]] -->

<!--   base.id.nongap <- which(!(base.seq %in% c("-", 'N'))) -->

<!--   # query.id.gap <- which(query.seq %in% c("-", 'N')) -->
<!--   # base.id.gap <- which(base.seq %in% c("-", 'N')) -->
<!--   # if(length(query.id.gap) + length(query.id) != length(base.id.gap) + length(base.id)) stop('problem!!!') -->

<!--   query.id.aln = rep(0, t[imatch, 'V7']) -->
<!--   query.id.aln[which(!(query.seq %in% c("-", 'N')))] <- query.id -->

<!--   query.id.in.base = query.id.aln[base.id.nongap] -->
<!--   base.seq.in.base = base.seq[base.id.nongap] -->

<!--   query.seq.in.base = query.seq -->
<!--   query.seq.in.base[query.seq == base.seq] = '' -->
<!--   query.seq.in.base = query.seq.in.base[base.id.nongap] -->


<!--   base.nt = paste(base.id, base.seq.in.base, sep = ':') -->

<!--   query.nt = paste(query.id.in.base, query.seq.in.base, sep = ':') -->
<!--   # query.nt[query.id.in.base != (c(0, query.id.in.base[1:(length(query.id.in.base)-1)]) + 1)] -->

<!--   base.tmp <- list() -->
<!--   base.tmp[base.nt] <- query.nt -->

<!--   base.pos <- c(base.pos, base.tmp) -->
<!--   # base.pos <- base.pos[!duplicated(base.pos)] -->
<!--   print(length(base.pos)) -->
<!-- } -->



<!-- dup.names = names(base.pos)[duplicated(names(base.pos))] -->
<!-- dup.name = dup.names[1] -->

<!-- base.pos[names(base.pos) %in% dup.name] -->
<!-- ``` -->



<!-- ```{r} -->
<!-- te <- read.table('/Volumes/Samsung_T5/vienn/base/te/TAIR10_Transposable_Elements.txt', header = 1) -->
<!-- te <- te[order(te$Transposon_min_Start),] -->
<!-- ``` -->



