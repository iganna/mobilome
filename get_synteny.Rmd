---
title: "R Notebook"
output: html_notebook
---




# Setup
```{r, message=FALSE}
library(ggplot2)
library(Biostrings)
library('seqinr')
library('spgs')  # reverseComplement("actg")
source("/Users/anna/OneDrive/pushkin/cryptic/nanopore/scripts/synteny_infer.R")

path.base = '/Volumes/Samsung_T5/vienn/tair/'
path.query = '/Volumes/Samsung_T5/vienn/renamed/'
path.blast.res <- '/Volumes/Samsung_T5/vienn/blast_res/'
path.t <- '/Volumes/Samsung_T5/vienn/alignments/'


files.base = list.files(path = path.base, pattern = ".fas")
base.pref = 'TAIR10_chr'

files.query = list.files(path = path.query, pattern = ".fasta")
query.name = gsub("*.fasta","",files.query)
```



# Read data
```{r}

query.chr = 5
base.chr = 5


i.query = 1  # which accession to use
i.query = which(query.name == '10012')

base.file = paste0(base.pref, query.chr ,'.fas', collapse = '')
query.file = files.query[i.query]
pref.blsat.res = paste0(query.name[i.query], '_', query.chr, '_', collapse = '')

base.fas.fw = read.fasta(paste(path.base, base.file, sep = ''))
query.fas = read.fasta(paste(path.query, query.file, sep = ''))

base.fas.fw = base.fas.fw[[1]] # do not remove this 1, file contains only one sequence
base.fas.bw = reverseComplement(base.fas.fw)
base.len = length(base.fas.fw)

query.fas.chr = query.fas[[query.chr]]

blast.res.file <- paste0(pref.blsat.res, as.character(base.chr), '.txt', collapse = '');

```



# Read blast results
```{r}


t = read.table(paste(path.blast.res, blast.res.file, sep = ''), stringsAsFactors = F, header = F)



# Remove duplicates
# t = t[!duplicated(t[,'V1']),]

# Remove short
t = t[t[,'V7'] > 500,]

# Remove low quality
quality.cutoff = 0.95
t = t[t[,'V6'] > quality.cutoff,]

# direction
t$dir = c()
for(irow in 1:nrow(t)) {
  if(t[irow,'V5'] < t[irow,'V4']) {
    
    pos1 = t[irow,'V5']
    pos2 = t[irow,'V4']
    
    t[irow,'V5'] <- length(base.fas.bw) - pos1 + 1
    t[irow,'V4'] <- length(base.fas.bw) - pos2 + 1
    t[irow, 'dir'] = 1
  } else {
    t[irow, 'dir'] = 0
  }
}

# Get right positions
start.pos = as.numeric(sapply(strsplit(t[,1], "\\|"), "[", 4)) - 1
t[,2:3] = t[,2:3] + start.pos

rownames(t) <- NULL

# check
for(irow in 1:nrow(t)) {
  if(nchar(t[irow,'V8']) != nchar(t[irow,'V9'])) stop('aaa')
}

source("/Users/anna/OneDrive/pushkin/cryptic/nanopore/scripts/synteny_infer.R")
checkCorrespToGenome(t, query.fas = query.fas.chr, 
                     base.fas.fw = base.fas.fw, 
                     base.fas.bw = base.fas.bw)
showt(t)


```





# First glue
```{r}

t = t[order(t[,'V4']),]

ipos = 1
while(ipos < nrow(t)) {
  # print(ipos)
  idx = which((t[,'V4'] == (t[ipos,'V5'] + 1)) & (t[,'V2'] == (t[ipos,'V3'] + 1)))
  if (length(idx) == 0){
    ipos = ipos+1
    next
  }
  
  # if(idx != (ipos+1)) print(idx)  # glue with not the next record
  
  t[ipos, 'V3'] <- t[idx, 'V3']
  t[ipos, 'V5'] <- t[idx, 'V5']
  t[ipos, 'V7'] <- t[ipos, 'V7'] + t[idx, 'V7']
  t[ipos, 'V8'] <- paste(t[ipos, 'V8'], t[idx, 'V8'], sep = '')
  t[ipos, 'V9'] <- paste(t[ipos, 'V9'], t[idx, 'V9'], sep = '')
  t <- t[-idx,]
}


rownames(t) <- NULL
t0 = t

```


## Distribution of gaps
```{r}

# plot(t[,'V4'], t[,'V2'])


plot( (base.len + 1) * t[,'dir'] + t[,'V4'] * ((-1) ^ t[,'dir']), t[,'V2'])

hist(log(t[2:(nrow(t)),'V2'] - t[1:(nrow(t)-1),'V3'], base = 10), 100)

sum(t[2:(nrow(t)),'V2'] - t[1:(nrow(t)-1),'V3'] < 10^3)
intersect(which(t[2:(nrow(t)),'V2'] - t[1:(nrow(t)-1),'V3'] > 10^4),
          which(t[2:(nrow(t)),'V4'] - t[1:(nrow(t)-1),'V5'] > 10^4))

setdiff(which(t[2:(nrow(t)),'V2'] - t[1:(nrow(t)-1),'V3'] > 10^4),
          which(t[2:(nrow(t)),'V4'] - t[1:(nrow(t)-1),'V5'] > 10^4))

```

# pairwise alignment
```{r}

file.log <- '/Users/anna/OneDrive/vienn/pacbio/log.txt'
thresholds = c(100, 1000, 2000)
# thresholds = c(1000)

t = glueByThreshold(t, thresholds, query.fas = query.fas.chr, 
                     base.fas.fw = base.fas.fw, 
                     base.fas.bw = base.fas.bw, file.log=file.log)
showt(t)

t1 = t


```

# Remove complete overlap from both sides (base an query)
```{r}
t.base = t

for(irow in 1:nrow(t.base)) {
  if(t.base[irow, 'dir'] == 1) {
    
    b1 <- t.base[irow,'V4']
    b2 <- t.base[irow,'V5']
    
    t.base[irow,'V4'] <- base.len - b1 + 1
    t.base[irow,'V5'] <- base.len - b2 + 1
  } 
}
t.base = t.base[order(t.base['V2']),]
showt(t.base)

# ------------------------------
# Overlap in base
irow = 1
while(irow < nrow(t.base)) {
  # index of all, that overlap with the current one (irow) in the right side
  idx = which((t.base[,'V4'] <= t.base[irow,'V4']) & 
                (t.base[,'V5'] >= t.base[irow,'V5']))
  if(length(idx) > 1) {
    t.base = t.base[-irow,] 
  } else {
    irow = irow + 1
  }
}

# Overlap in query
irow = 1
while(irow < nrow(t.base)) {
  # index of all, that overlap with the current one (irow) in the right side
  idx = which((t.base[,'V2'] <= t.base[irow,'V2']) & 
                (t.base[,'V3'] >= t.base[irow,'V3']))
  if(length(idx) > 1) {
    t.base = t.base[-irow,] 
  } else {
    irow = irow + 1
  }
}

showt(t.base)

ids.remove = which((t.base[, 'dir'] > 0) & (t.base[, 'V7'] < 5000))
if(length(ids.remove) > 0) {
  t.base = t.base[-ids.remove,]
}


idx = rep(F, base.len)
for(irow in 1:nrow(t.base)){
  idx[t.base[irow,'V4']:t.base[irow,'V5']] = T
}

coverage = sum(idx) / base.len
print(coverage)


idx = rep(F, length(query.fas.chr))
for(irow in 1:nrow(t.base)){
  idx[t.base[irow,'V2']:t.base[irow,'V3']] = T
}

coverage = sum(idx) / length(idx)
print(coverage)

# remove distant outliers


plot(t.base[,'V4'], t.base[,'V2'])

t = t[rownames(t.base),]
```

## Additional glue
```{r}

t = glueByThreshold(t, c(3000, 4000), query.fas = query.fas.chr, 
                     base.fas.fw = base.fas.fw, 
                     base.fas.bw = base.fas.bw, file.log=file.log)

```

# Plot syntheny blocks
```{r fig.width=3, fig.height=3}
df = c()
for(i in 1:nrow(t)) {
  if(t$dir[i] == 0){
    df = rbind(df, c(t[i, 'V2'], t[i, 'V4'], i, 0))
    df = rbind(df, c(t[i, 'V3'], t[i, 'V5'], i, 0))
  } else {
    df = rbind(df, c(t[i, 'V2'], length(base.fas.fw) - t[i, 'V4'] + 1, i, 1))
    df = rbind(df, c(t[i, 'V3'], length(base.fas.fw) - t[i, 'V5'] + 1, i, 1))
  }
    
}

df = as.data.frame(df)
df$clr <- df$V3 %% 2;
p <- ggplot(df, aes(x = V1, y=V2, color = as.factor(V4), group=as.factor(V3)  )) + 
  geom_line(show.legend = FALSE) + theme_bw()
p

```

## Save
```{r}

saveRDS(object = t, file = paste(path.t, 
                                 paste0(pref.blsat.res, as.character(base.chr), 
                                        '.rds', collapse = ''), sep = ''))


# t1 = readRDS(file = paste(path.t, blast.res.file, sep = ''))

```




# Get total alignment
```{r}
t.base = t
for(irow in 1:nrow(t.base)) {
  if(t.base[irow, 'dir'] == 1) {
    
    b1 <- t.base[irow,'V4']
    b2 <- t.base[irow,'V5']
    
    t.base[irow,'V4'] <- base.len - b2 + 1
    t.base[irow,'V5'] <- base.len - b1 + 1
    
    q1 <- t.base[irow,'V2']
    q2 <- t.base[irow,'V3']

    t.base[irow,'V2'] <- -q2
    t.base[irow,'V3'] <- -q1
    
    t.base[irow, 'V8'] <- reverseComplement(t.base[irow, 'V8'])
    t.base[irow, 'V9'] <- reverseComplement(t.base[irow, 'V9'])
  } 
}

aln.pos = rep(0, base.len)
aln.nt = rep('-', base.len)

for(irow in 1:nrow(t)) {
  s.q = strsplit(t[irow, 'V8'], '')[[1]]
  s.b = strsplit(t[irow, 'V9'], '')[[1]]
  
  print(sum(s.q != s.b))
  
  pos.q = rep(0, t[irow, 'V7'])
  pos.q[s.q != '-'] <- t[irow, 'V2']:t[irow, 'V3']
  pos.b = t[irow, 'V4']:t[irow, 'V5']
  
  idx.b = which(s.b == '-')
  if(length(idx.b) > 0) {
    pos.q = pos.q[-idx.b]
    s.q = s.q[-idx.b]  
  }
  
  
  # if(sum(aln.nt != '-') == 0) {
    aln.pos[pos.b] = pos.q
    aln.nt[pos.b] = s.q
  # } else {
  #   stop('ss')
  # }
}
```

# Get SNPs
```{r}
snp.pos = which((aln.nt != '-') & (aln.nt != toupper(base.fas.fw)))


flanking.match = 3
idx = (snp.pos[-1] - snp.pos[-length(snp.pos)]) > flanking.match
idx = c(idx, T) & c(T, idx)
snp.pos = snp.pos[idx]


```


# Mobilome
```{r}
mobilome <- c()

for(irow in 1:nrow(t)) {
# for(irow in 1:50) {
  s.query <- strsplit(t[irow, 'V8'], '')[[1]]
  s.base <- strsplit(t[irow, 'V9'], '')[[1]]
  s <- c()
  f <- ''
  for(icol in 1:length(s.query)){
    if(s.query[icol] == '-') {
      if(f == 'query'){
        if(length(s) > 0) mobilome <- c(mobilome, paste0(s, collapse =''))
        s <- c()
      }
      f = 'base' # get sequence from base
      s <- c(s, s.base[icol])
    } else if(s.base[icol] == '-') {
      if(f == 'base'){ 
        if(length(s) > 0) mobilome <- c(mobilome, paste0(s, collapse =''))
        s <- c()
      }
      f = 'query'
      s <- c(s, s.query[icol])
    } else if (length(s) > 0) {
      mobilome <- c(mobilome, paste0(s, collapse =''))
      s <- c()
      f = ''
    }
  }
}

```




```{r}

mobilome.t <- table(mobilome)
mobilome.unique.len <- sapply(names(mobilome.t), nchar)
mobilome.t = mobilome.t[order(mobilome.unique.len)]
mobilome.unique.len <- sapply(names(mobilome.t), nchar)



plot(log(mobilome.t, base = 2))


idx <- (mobilome.t > 2^2) & (mobilome.t < 2^6) &
  (rank(mobilome.unique.len) > length(mobilome.t)/3)

mobilome.t[idx]


mobilome.t[(mobilome.unique.len>15) & (mobilome.unique.len<100)]


for(len in 15:50){
  mobilome.prev = names(mobilome.t[mobilome.unique.len == (len-1)])

  tmp = mobilome.t[mobilome.unique.len == (len-1)]
  tmp[tmp >1]

  mobilome.prev = names(tmp[tmp >1])

  scores = c()
  for(i in 1:length(mobilome.prev)) {
    for(j in i:length(mobilome.prev)) {
      if (i == j) next
        seq1 <- mobilome.prev[i]
        seq2 <- mobilome.prev[j]
        globalAlign<- pairwiseAlignment(seq1, seq2)
        scores = rbind(scores, c(i, j, globalAlign@score))
    }
  }
}

```



<!-- ```{r} -->
<!-- nts <- c('A', 'C', 'G', 'T') -->
<!-- cnt <- mobilome.t[nts] -->
<!-- freq <- cnt / sum(cnt) -->

<!-- cmb <- gtools::permutations(4, 7, repeats.allowed=TRUE) -->
<!-- nts.cmb <- sapply(1:nrow(cmb), function(i) paste0(nts[cmb[i,]], collapse = '')) -->

<!-- cnt.cmb <- mobilome.t[nts.cmb] -->

<!-- freq.cmb <- sapply(1:nrow(cmb), function(i) prod(freq[cmb[i,]])) -->

<!-- plot(freq.cmb, cnt.cmb) -->

<!-- text(freq.cmb, cnt.cmb, nts.cmb, cex=0.5, pos=3,col="red", adj = c(0,1)) -->

<!-- ``` -->


<!-- ```{r} -->
<!-- d<-head(mtcars) -->
<!-- plot(d[,'wt'], d[,'mpg'],  -->
<!--      main="Milage vs. Car Weight\n~~~~~~~~~~~~~~~~~~~", -->
<!--       xlab="Weight", ylab="Miles/(US) gallon", -->
<!--       pch=19, col="darkgreen") -->
<!-- text(d[,'wt'], d[,'mpg'],  row.names(d), -->
<!--      cex=0.65, pos=3,col="red")  -->
<!-- ``` -->


<!-- ```{r} -->
<!-- # find the largest list, which is sorted. -->

<!-- hist(abs(t[2:nrow(t),'V4'] - t[1:(nrow(t) - 1),'V4'])) -->

<!-- plot(t[,'V4'], t[,'V2']) -->

<!-- t = t[order(t[,'V4']),] -->


<!-- base.pos = list() -->
<!-- for(imatch in 1:nrow(t)) { -->

<!--   query.id <- t[imatch, 'V2']:t[imatch, 'V3'] -->
<!--   base.id <- t[imatch, 'V4']:t[imatch, 'V5'] -->

<!--   t[imatch, 'V8'] = toupper(t[imatch, 'V8']) -->
<!--   t[imatch, 'V9'] = toupper(t[imatch, 'V9']) -->

<!--   query.seq = strsplit(t[imatch, 'V8'], "")[[1]] -->
<!--   base.seq = strsplit(t[imatch, 'V9'], "")[[1]] -->

<!--   base.id.nongap <- which(!(base.seq %in% c("-", 'N'))) -->

<!--   # query.id.gap <- which(query.seq %in% c("-", 'N')) -->
<!--   # base.id.gap <- which(base.seq %in% c("-", 'N')) -->
<!--   # if(length(query.id.gap) + length(query.id) != length(base.id.gap) + length(base.id)) stop('problem!!!') -->

<!--   query.id.aln = rep(0, t[imatch, 'V7']) -->
<!--   query.id.aln[which(!(query.seq %in% c("-", 'N')))] <- query.id -->

<!--   query.id.in.base = query.id.aln[base.id.nongap] -->
<!--   base.seq.in.base = base.seq[base.id.nongap] -->

<!--   query.seq.in.base = query.seq -->
<!--   query.seq.in.base[query.seq == base.seq] = '' -->
<!--   query.seq.in.base = query.seq.in.base[base.id.nongap] -->


<!--   base.nt = paste(base.id, base.seq.in.base, sep = ':') -->

<!--   query.nt = paste(query.id.in.base, query.seq.in.base, sep = ':') -->
<!--   # query.nt[query.id.in.base != (c(0, query.id.in.base[1:(length(query.id.in.base)-1)]) + 1)] -->

<!--   base.tmp <- list() -->
<!--   base.tmp[base.nt] <- query.nt -->

<!--   base.pos <- c(base.pos, base.tmp) -->
<!--   # base.pos <- base.pos[!duplicated(base.pos)] -->
<!--   print(length(base.pos)) -->
<!-- } -->



<!-- dup.names = names(base.pos)[duplicated(names(base.pos))] -->
<!-- dup.name = dup.names[1] -->

<!-- base.pos[names(base.pos) %in% dup.name] -->
<!-- ``` -->



<!-- ```{r} -->
<!-- te <- read.table('/Volumes/Samsung_T5/vienn/base/te/TAIR10_Transposable_Elements.txt', header = 1) -->
<!-- te <- te[order(te$Transposon_min_Start),] -->
<!-- ``` -->



